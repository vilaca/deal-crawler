name: CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  test:
    name: Test & Lint
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python 3.13
        uses: actions/setup-python@v5
        with:
          python-version: '3.13'
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements-dev.txt

      # FAILURE POINT 1: Tests failed
      # Possible causes:
      #   - Test assertion failures (code behavior doesn't match expectations)
      #   - Import errors or missing dependencies
      #   - Test setup/teardown issues
      # Fix: Run 'make test' locally to see which tests fail, fix the code, ensure all tests pass
      - name: Run tests
        run: make test

      # FAILURE POINT 2: Coverage check failed
      # Possible causes:
      #   - Test coverage below threshold (check Makefile for minimum percentage)
      #   - New code added without tests
      #   - Tests not running or not detecting code paths
      # Fix: Run 'make coverage' locally, add tests for uncovered code, aim for >95% coverage
      - name: Run coverage
        run: |
          make coverage | tee coverage-output.txt

      - name: Extract coverage for PR comments
        if: github.event_name == 'pull_request'
        run: |
          # Extract current coverage
          COVERAGE=$(grep "TOTAL" coverage-output.txt | awk '{print $4}' | sed 's/%//')
          echo "CURRENT_COVERAGE=$COVERAGE" >> $GITHUB_ENV
          echo "Current coverage: $COVERAGE%"

          # Get baseline coverage from main branch README
          BASELINE=$(curl -s https://raw.githubusercontent.com/${{ github.repository }}/main/README.md | grep -oP 'coverage-\K[0-9]+' | head -1)
          echo "BASELINE_COVERAGE=$BASELINE" >> $GITHUB_ENV
          echo "Baseline coverage: $BASELINE%"

      - name: Update coverage badge
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        run: |
          # Extract coverage percentage from output
          COVERAGE=$(grep "TOTAL" coverage-output.txt | awk '{print $4}' | sed 's/%//')

          if [ -n "$COVERAGE" ]; then
            echo "Coverage: $COVERAGE%"

            # Update README badge
            sed -i "s/coverage-[0-9]*%25/coverage-${COVERAGE}%25/" README.md

            # Check if README was modified
            if git diff --quiet README.md; then
              echo "Coverage badge already up to date"
            else
              # Configure git
              git config --local user.email "github-actions[bot]@users.noreply.github.com"
              git config --local user.name "github-actions[bot]"

              # Commit and push
              git add README.md
              git commit -m "Update coverage badge to ${COVERAGE}% [skip ci]"
              git push
            fi
          else
            echo "Could not extract coverage percentage"
          fi

      - name: Check code formatting
        run: make format-check > black-report.txt 2>&1 || true

      - name: Lint with flake8 and pylint
        run: |
          make lint > lint-full-report.txt 2>&1 || true
          # Extract just pylint output for PR comments
          grep -A9999 "Running pylint" lint-full-report.txt | tail -n +2 > pylint-report.txt || true

      # FAILURE POINT 3: Type checking failed
      # Possible causes:
      #   - Type annotation errors (wrong types, missing types)
      #   - mypy configuration issues
      #   - Incompatible type operations (e.g., int + None)
      # Fix: Run 'make typecheck' locally, add/fix type hints, use 'assert' for type narrowing
      - name: Type check with mypy
        run: make typecheck

      - name: Check dead code
        run: |
          make vulture > vulture-report.txt 2>&1 || true

      # FAILURE POINT 4: Missing docstrings
      # Possible causes:
      #   - Functions/classes/methods missing docstrings
      #   - Docstring coverage below 100%
      # Fix: Run 'make interrogate' locally, add docstrings to all functions/classes
      - name: Check docstring coverage
        run: make interrogate

      - name: Check code complexity
        run: make complexity > complexity-report.txt 2>&1 || true

      - name: Post failure explanation as PR comment
        if: failure() && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            // Unique identifier to find and update existing comments
            const commentMarker = '<!-- ci-failure-help-comment -->';

            // Build failure explanation comment
            let comment = commentMarker + '\n## ‚ùå CI Pipeline Failed\n\n';
            comment += 'Your PR has failing quality checks. Here\'s what to do:\n\n';

            // Add specific guidance based on common failures
            comment += '### üîç Debugging Steps\n\n';
            comment += '1. **Check the failed step** in the Actions tab above\n';
            comment += '2. **Look at the error output** in the logs\n';
            comment += '3. **Run the corresponding command locally** to reproduce the issue\n\n';

            comment += '### üõ†Ô∏è Common Failure Points & Fixes\n\n';

            comment += '#### ‚ùå Tests Failed\n';
            comment += '**Symptoms:** Test assertion errors, import errors, or setup issues\n\n';
            comment += '**Fix:**\n';
            comment += '```bash\n';
            comment += 'make test  # Run locally to see which tests fail\n';
            comment += '```\n';
            comment += '- Fix failing test assertions by correcting the code logic\n';
            comment += '- Ensure all imports are correct and dependencies installed\n';
            comment += '- Update tests if behavior intentionally changed\n\n';

            comment += '#### üìä Coverage Failed\n';
            comment += '**Symptoms:** Coverage below threshold (check Makefile for minimum %)\n\n';
            comment += '**Fix:**\n';
            comment += '```bash\n';
            comment += 'make coverage  # See which lines are uncovered\n';
            comment += '```\n';
            comment += '- Add tests for new functions/classes you created\n';
            comment += '- Add tests for uncovered branches (if/else, error paths)\n';
            comment += '- Target: >95% coverage for all new code\n\n';

            comment += '#### üî§ Type Check Failed\n';
            comment += '**Symptoms:** mypy errors about type mismatches or missing annotations\n\n';
            comment += '**Fix:**\n';
            comment += '```bash\n';
            comment += 'make typecheck  # See type errors\n';
            comment += '```\n';
            comment += '- Add type hints to function parameters and return types\n';
            comment += '- Use `assert x is not None` for type narrowing\n';
            comment += '- Fix incompatible type operations (e.g., `Optional[int] + int`)\n\n';

            comment += '#### üìù Docstrings Missing\n';
            comment += '**Symptoms:** interrogate reports missing docstrings\n\n';
            comment += '**Fix:**\n';
            comment += '```bash\n';
            comment += 'make interrogate  # See what needs docs\n';
            comment += '```\n';
            comment += '- Add docstrings to all public functions and classes\n';
            comment += '- Follow format: `"""Brief description.\\n\\nDetailed explanation."""`\n';
            comment += '- Document parameters using Args: section if needed\n\n';

            comment += '### üìö Quick Reference\n\n';
            comment += '| Command | Purpose |\n';
            comment += '|---------|----------|\n';
            comment += '| `make test` | Run all tests |\n';
            comment += '| `make coverage` | Check test coverage |\n';
            comment += '| `make typecheck` | Check type hints |\n';
            comment += '| `make lint` | Run pylint & flake8 |\n';
            comment += '| `make format` | Auto-fix formatting |\n';
            comment += '| `make help` | See all available commands |\n\n';

            comment += '---\n';
            comment += '_üí° Tip: Always run `make test && make typecheck` locally before pushing!_\n';

            // Check for existing comment from this bot
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number
            });

            const existingComment = comments.find(c =>
              c.user.login === 'github-actions[bot]' &&
              c.body.includes(commentMarker)
            );

            if (existingComment) {
              // Update existing comment
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existingComment.id,
                body: comment
              });
              console.log('Updated existing CI failure help comment');
            } else {
              // Create new comment
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: comment
              });
              console.log('Created new CI failure help comment');
            }

      - name: Check security with bandit
        run: |
          make bandit > bandit-report.txt 2>&1 || true

      - name: Check dependency vulnerabilities
        run: |
          make pip-audit > pip-audit-report.txt 2>&1 || true

      - name: Post warnings as PR comment
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            // Read reports
            const black = fs.existsSync('black-report.txt') ? fs.readFileSync('black-report.txt', 'utf8') : 'No formatting issues';
            const pylint = fs.existsSync('pylint-report.txt') ? fs.readFileSync('pylint-report.txt', 'utf8') : 'No issues found';
            const bandit = fs.existsSync('bandit-report.txt') ? fs.readFileSync('bandit-report.txt', 'utf8') : 'No issues found';
            const vulture = fs.existsSync('vulture-report.txt') ? fs.readFileSync('vulture-report.txt', 'utf8') : 'No dead code found';
            const pipaudit = fs.existsSync('pip-audit-report.txt') ? fs.readFileSync('pip-audit-report.txt', 'utf8') : 'No vulnerabilities found';
            const complexity = fs.existsSync('complexity-report.txt') ? fs.readFileSync('complexity-report.txt', 'utf8') : 'No complexity issues';

            // Get coverage from environment variables
            const currentCoverage = parseFloat(process.env.CURRENT_COVERAGE || '0');
            const baselineCoverage = parseFloat(process.env.BASELINE_COVERAGE || '0');
            const coverageDrop = baselineCoverage - currentCoverage;
            const hasCoverageDrop = coverageDrop > 0;

            // Check if there are actual warnings
            const hasBlackWarnings = black.includes('would be reformatted') || black.includes('error');

            // Parse pylint score and check for issues
            const pylintScoreMatch = pylint.match(/Your code has been rated at ([\d.]+)\/10/);
            const pylintScore = pylintScoreMatch ? pylintScoreMatch[1] : null;
            const hasPylintWarnings = pylint.includes('************* Module') || (pylintScore && parseFloat(pylintScore) < 10.0);

            const hasBanditWarnings = !bandit.includes('No issues identified');
            const hasVultureWarnings = vulture.trim().length > 0 && !vulture.includes('No dead code');
            const hasPipAuditWarnings = pipaudit.includes('Found') && pipaudit.includes('vulnerability');

            // Check for complexity issues (grade C or worse)
            // Match radon's output format: " - C" or " - D" etc. (after function names or file names)
            const complexityWarningPattern = / - [C-F](\s|\(|$)/;
            const hasComplexityWarnings = complexityWarningPattern.test(complexity);

            // Only post if there are warnings
            if (!hasBlackWarnings && !hasPylintWarnings && !hasBanditWarnings && !hasVultureWarnings && !hasPipAuditWarnings && !hasComplexityWarnings && !hasCoverageDrop) {
              console.log('No warnings to report');
              return;
            }

            // Build comment
            let comment = '## ‚ö†Ô∏è Code Quality Warnings\n\n';
            comment += '_These warnings do not block the PR but should be reviewed._\n\n';

            // Add pylint score at the top if available
            if (pylintScore) {
              const scoreEmoji = parseFloat(pylintScore) >= 9.5 ? '‚≠ê' : parseFloat(pylintScore) >= 8.0 ? '‚úÖ' : '‚ö†Ô∏è';
              comment += `### üéØ Code Quality Score: **${pylintScore}/10** ${scoreEmoji}\n\n`;
            }

            // Add coverage warning if coverage dropped
            if (hasCoverageDrop) {
              const dropEmoji = coverageDrop >= 5 ? 'üö®' : coverageDrop >= 2 ? '‚ö†Ô∏è' : 'üìâ';
              comment += `### ${dropEmoji} Test Coverage Drop\n`;
              comment += `- **Baseline (main)**: ${baselineCoverage}%\n`;
              comment += `- **Current (PR)**: ${currentCoverage}%\n`;
              comment += `- **Drop**: -${coverageDrop.toFixed(1)}%\n\n`;
              if (coverageDrop >= 5) {
                comment += '_‚ö†Ô∏è Significant coverage drop! Please add tests for new code._\n\n';
              } else {
                comment += '_Please ensure new code has adequate test coverage._\n\n';
              }
            }

            if (hasBlackWarnings) {
              comment += '### ‚ú® Code Formatting Issues (black)\n';
              comment += '```\n' + black + '\n```\n\n';
              comment += '_Run `make format` to fix formatting issues._\n\n';
            }

            if (hasPylintWarnings) {
              comment += '### üîç Code Quality Issues (pylint)\n';
              comment += '```\n' + pylint + '\n```\n\n';
            }

            if (hasBanditWarnings) {
              comment += '### üîí Security Issues (bandit)\n';
              comment += '```\n' + bandit + '\n```\n\n';
            }

            if (hasVultureWarnings) {
              comment += '### üßπ Dead Code Detection (vulture)\n';
              comment += '```\n' + vulture + '\n```\n\n';
            }

            if (hasPipAuditWarnings) {
              comment += '### üì¶ Dependency Vulnerabilities (pip-audit)\n';
              comment += '```\n' + pipaudit + '\n```\n\n';
            }

            if (hasComplexityWarnings) {
              comment += '### üìä Code Complexity Issues (radon)\n';
              comment += '```\n' + complexity + '\n```\n\n';
              comment += '_Functions with grade C or worse should be refactored. Target: A-B complexity._\n\n';
            }

            comment += '---\n';

            // Post comment
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: comment
            });

  quality-summary:
    name: Quality Summary
    runs-on: ubuntu-latest
    needs: test
    if: always()

    steps:
      # FAILURE POINT 5: Quality checks failed
      # This step fails if ANY of the previous steps failed
      # What to check:
      #   1. Look at the failed step name in the Actions UI
      #   2. Read the failure point comment for that specific step above
      #   3. Check the error output in that step's logs
      #   4. Run the corresponding 'make' command locally to reproduce
      # Common fixes:
      #   - Tests failed ‚Üí Fix code logic, update tests
      #   - Coverage failed ‚Üí Add tests for new code
      #   - Type check failed ‚Üí Fix type annotations
      #   - Docstrings failed ‚Üí Add missing docstrings
      - name: Check test results
        run: |
          if [ "${{ needs.test.result }}" == "success" ]; then
            echo "‚úÖ All quality checks passed!"
          else
            echo "‚ùå Some quality checks failed"
            echo "Check the failed step above and follow the FAILURE POINT comments for guidance"
            exit 1
          fi
