name: CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  test:
    name: Test & Lint
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python 3.13
        uses: actions/setup-python@v5
        with:
          python-version: '3.13'
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Run tests
        run: make test

      - name: Run coverage
        run: |
          make coverage | tee coverage-output.txt

      - name: Extract coverage for PR comments
        if: github.event_name == 'pull_request'
        run: |
          # Extract current coverage
          COVERAGE=$(grep "TOTAL" coverage-output.txt | awk '{print $4}' | sed 's/%//')
          echo "CURRENT_COVERAGE=$COVERAGE" >> $GITHUB_ENV
          echo "Current coverage: $COVERAGE%"

          # Get baseline coverage from main branch README
          BASELINE=$(curl -s https://raw.githubusercontent.com/${{ github.repository }}/main/README.md | grep -oP 'coverage-\K[0-9]+' | head -1)
          echo "BASELINE_COVERAGE=$BASELINE" >> $GITHUB_ENV
          echo "Baseline coverage: $BASELINE%"

      - name: Update coverage badge
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        run: |
          # Extract coverage percentage from output
          COVERAGE=$(grep "TOTAL" coverage-output.txt | awk '{print $4}' | sed 's/%//')

          if [ -n "$COVERAGE" ]; then
            echo "Coverage: $COVERAGE%"

            # Update README badge
            sed -i "s/coverage-[0-9]*%25/coverage-${COVERAGE}%25/" README.md

            # Check if README was modified
            if git diff --quiet README.md; then
              echo "Coverage badge already up to date"
            else
              # Configure git
              git config --local user.email "github-actions[bot]@users.noreply.github.com"
              git config --local user.name "github-actions[bot]"

              # Commit and push
              git add README.md
              git commit -m "Update coverage badge to ${COVERAGE}% [skip ci]"
              git push
            fi
          else
            echo "Could not extract coverage percentage"
          fi

      - name: Check code formatting
        run: make format-check > black-report.txt 2>&1 || true

      - name: Lint with flake8 and pylint
        run: |
          make lint > lint-full-report.txt 2>&1 || true
          # Extract just pylint output for PR comments
          grep -A9999 "Running pylint" lint-full-report.txt | tail -n +2 > pylint-report.txt || true

      - name: Type check with mypy
        run: make typecheck

      - name: Check dead code
        run: |
          vulture main.py utils test --min-confidence 100 > vulture-report.txt 2>&1 || true

      - name: Check docstring coverage
        run: |
          interrogate -v main.py utils test --fail-under 100

      - name: Check code complexity
        run: make complexity > complexity-report.txt 2>&1 || true

      - name: Check security with bandit
        run: |
          bandit -r main.py utils test -ll > bandit-report.txt 2>&1 || true

      - name: Check dependency vulnerabilities
        run: |
          pip-audit --desc > pip-audit-report.txt 2>&1 || true

      - name: Post warnings as PR comment
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            // Read reports
            const black = fs.existsSync('black-report.txt') ? fs.readFileSync('black-report.txt', 'utf8') : 'No formatting issues';
            const pylint = fs.existsSync('pylint-report.txt') ? fs.readFileSync('pylint-report.txt', 'utf8') : 'No issues found';
            const bandit = fs.existsSync('bandit-report.txt') ? fs.readFileSync('bandit-report.txt', 'utf8') : 'No issues found';
            const vulture = fs.existsSync('vulture-report.txt') ? fs.readFileSync('vulture-report.txt', 'utf8') : 'No dead code found';
            const pipaudit = fs.existsSync('pip-audit-report.txt') ? fs.readFileSync('pip-audit-report.txt', 'utf8') : 'No vulnerabilities found';
            const complexity = fs.existsSync('complexity-report.txt') ? fs.readFileSync('complexity-report.txt', 'utf8') : 'No complexity issues';

            // Get coverage from environment variables
            const currentCoverage = parseFloat(process.env.CURRENT_COVERAGE || '0');
            const baselineCoverage = parseFloat(process.env.BASELINE_COVERAGE || '0');
            const coverageDrop = baselineCoverage - currentCoverage;
            const hasCoverageDrop = coverageDrop > 0;

            // Check if there are actual warnings
            const hasBlackWarnings = black.includes('would be reformatted') || black.includes('error');

            // Parse pylint score and check for issues
            const pylintScoreMatch = pylint.match(/Your code has been rated at ([\d.]+)\/10/);
            const pylintScore = pylintScoreMatch ? pylintScoreMatch[1] : null;
            const hasPylintWarnings = pylint.includes('************* Module') || (pylintScore && parseFloat(pylintScore) < 10.0);

            const hasBanditWarnings = !bandit.includes('No issues identified');
            const hasVultureWarnings = vulture.trim().length > 0 && !vulture.includes('No dead code');
            const hasPipAuditWarnings = pipaudit.includes('Found') && pipaudit.includes('vulnerability');

            // Check for complexity issues (grade C or worse)
            // Match radon's output format: " - C" or " - D" etc. (after function names or file names)
            const complexityWarningPattern = / - [C-F](\s|\(|$)/;
            const hasComplexityWarnings = complexityWarningPattern.test(complexity);

            // Only post if there are warnings
            if (!hasBlackWarnings && !hasPylintWarnings && !hasBanditWarnings && !hasVultureWarnings && !hasPipAuditWarnings && !hasComplexityWarnings && !hasCoverageDrop) {
              console.log('No warnings to report');
              return;
            }

            // Build comment
            let comment = '## ‚ö†Ô∏è Code Quality Warnings\n\n';
            comment += '_These warnings do not block the PR but should be reviewed._\n\n';

            // Add pylint score at the top if available
            if (pylintScore) {
              const scoreEmoji = parseFloat(pylintScore) >= 9.5 ? '‚≠ê' : parseFloat(pylintScore) >= 8.0 ? '‚úÖ' : '‚ö†Ô∏è';
              comment += `### üéØ Code Quality Score: **${pylintScore}/10** ${scoreEmoji}\n\n`;
            }

            // Add coverage warning if coverage dropped
            if (hasCoverageDrop) {
              const dropEmoji = coverageDrop >= 5 ? 'üö®' : coverageDrop >= 2 ? '‚ö†Ô∏è' : 'üìâ';
              comment += `### ${dropEmoji} Test Coverage Drop\n`;
              comment += `- **Baseline (main)**: ${baselineCoverage}%\n`;
              comment += `- **Current (PR)**: ${currentCoverage}%\n`;
              comment += `- **Drop**: -${coverageDrop.toFixed(1)}%\n\n`;
              if (coverageDrop >= 5) {
                comment += '_‚ö†Ô∏è Significant coverage drop! Please add tests for new code._\n\n';
              } else {
                comment += '_Please ensure new code has adequate test coverage._\n\n';
              }
            }

            if (hasBlackWarnings) {
              comment += '### ‚ú® Code Formatting Issues (black)\n';
              comment += '```\n' + black + '\n```\n\n';
              comment += '_Run `make format` to fix formatting issues._\n\n';
            }

            if (hasPylintWarnings) {
              comment += '### üîç Code Quality Issues (pylint)\n';
              comment += '```\n' + pylint + '\n```\n\n';
            }

            if (hasBanditWarnings) {
              comment += '### üîí Security Issues (bandit)\n';
              comment += '```\n' + bandit + '\n```\n\n';
            }

            if (hasVultureWarnings) {
              comment += '### üßπ Dead Code Detection (vulture)\n';
              comment += '```\n' + vulture + '\n```\n\n';
            }

            if (hasPipAuditWarnings) {
              comment += '### üì¶ Dependency Vulnerabilities (pip-audit)\n';
              comment += '```\n' + pipaudit + '\n```\n\n';
            }

            if (hasComplexityWarnings) {
              comment += '### üìä Code Complexity Issues (radon)\n';
              comment += '```\n' + complexity + '\n```\n\n';
              comment += '_Functions with grade C or worse should be refactored. Target: A-B complexity._\n\n';
            }

            comment += '---\n';

            // Post comment
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: comment
            });

  quality-summary:
    name: Quality Summary
    runs-on: ubuntu-latest
    needs: test
    if: always()

    steps:
      - name: Check test results
        run: |
          if [ "${{ needs.test.result }}" == "success" ]; then
            echo "‚úÖ All quality checks passed!"
          else
            echo "‚ùå Some quality checks failed"
            exit 1
          fi
